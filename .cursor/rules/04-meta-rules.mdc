---
alwaysApply: true
---

# Junior Rule 04: Meta-Rules - Writing Documentation for Junior

## Three Modes of Documentation

### Mode A: Junior → Junior (Internal Rules)
**Audience:** AI (me)
**Purpose:** Triggers, reminders, context

**What to include:**
- ✅ Triggers (when to think about X)
- ✅ Project-specific decisions
- ✅ Real examples from THIS codebase
- ✅ Measurable results

**What to exclude:**
- ❌ Pattern definitions (I know them)
- ❌ How concepts work (I know them)
- ❌ Generic examples (not helpful)
- ❌ Universal knowledge (textbook stuff)
- ❌ **Implementation code** (bash scripts, code snippets I can write myself)

**Good example:**
```markdown
## Pattern Triggers
Manual setup/cleanup pairs → Context Manager
- Example: exchange_context() saved 45 lines/usage
```

**Bad example (includes code I already know):**
```markdown
## Stage Detection

Check for comp-*/ directories:
```bash
if ! ls .junior/features/comp-* 1>/dev/null 2>&1; then
  echo "stage1"
fi
```

**Why bad:** I (the AI) already know how to check for directories and conditionals. Just describe WHAT to detect, not HOW to write the bash code.

**Better:**
```markdown
## Stage Detection

**Process:** Check for comp-*/ directories under .junior/features/. If none exist → stage1. If exist, check for features/ subdirectory within. Returns: stage1, stage2, or stage3.
```

### Mode B: Junior → Junior + User (Specs/Decisions)
**Audience:** AI + Human review
**Purpose:** Technical decisions with context

**What to include:**
- ✅ Triggers and reminders for Junior
- ✅ Enough context for user to understand
- ✅ Rationale for decisions
- ✅ Trade-offs considered

**What to exclude:**
- ❌ Over-explaining to Junior (you know it)
- ❌ Over-explaining to expert user (they know it)
- ❌ Patterns the user already understands

**Example:**
```markdown
## Decision: Context Manager for Stream Exchange

**Problem:** Manual buffer management repeated in 3 protocols
**Solution:** extract_context() context manager
**Why:** Guarantees cleanup, exception-safe, reduces duplication
**Result:** 45 lines → 3 lines per usage
```

### Mode C: Junior → User (Documentation)
**Audience:** End users, developers using the code
**Purpose:** Teach and explain

**What to include:**
- ✅ What patterns are (they may not know)
- ✅ How things work (step by step)
- ✅ Examples with explanation
- ✅ Why we chose this approach
- ✅ How to use the code

**What to exclude:**
- ❌ Implementation details (unless needed)
- ❌ Junior-specific triggers

**Example:**
```markdown
## Stream Exchange Pattern

The library uses context managers for stream operations:

```python
async with stream.exchange_context():
    data = await stream.wait_for_data(size=100)
```

This pattern ensures:
- Buffer is prepared before receiving
- Cleanup happens automatically
- Exception-safe operation
```

## Documentation Test

**Before writing, ask:**

1. **"Who is the primary audience?"**
   - Me only → Mode A (triggers)
   - Me + User review → Mode B (context)
   - End user → Mode C (teach)

2. **"What does the audience already know?"**
   - Me → Everything technical
   - Expert user → Domain patterns
   - End user → May need explanations

3. **"What's the purpose?"**
   - Trigger behavior → Mode A
   - Document decision → Mode B
   - Teach usage → Mode C

## What Junior Already Knows

**Universal knowledge (don't document for Junior):**
- Design patterns (Strategy, Factory, Observer, RAII, Context Manager, etc.)
- Programming concepts (DRY, SOLID, coupling, cohesion, etc.)
- Language syntax and standard libraries
- Common algorithms and data structures
- Industry best practices and conventions

**If Wikipedia or a textbook has it, Junior doesn't need it.**

## What Junior Learns

**Project-specific knowledge (DO document for Junior):**
- When to apply patterns in THIS codebase
- "We tried X, didn't work, use Y instead"
- User's specific preferences and decisions
- Codebase-specific architectural choices
- Real examples where patterns helped HERE

## CRITICAL: No Project Leakage into Generic "Junior" Documents

**Documents with "Junior" in the title must remain portable across projects.**

**Project-specific documents (no "Junior" in title) CAN and SHOULD include project details:**
- Feature/improvement/debugging docs in `.junior/`
- Project-specific architectural decisions
- Code examples from current codebase
- "In this project we..." language is APPROPRIATE

**⚠️ WHEN WRITING/UPDATING JUNIOR RULES:**
1. **Use generic placeholders:** "Story X", "Task N", "Feature Y" - NOT "Story 2", "Task 1.3"
2. **Use abstract examples:** "add authentication" NOT "add BLE scanning"
3. **Check before saving:** Would this example make sense in ANY project?
4. **Grep check:** Search for specific story/task numbers in the rule file itself

**Test:** If Junior moved to a completely different project tomorrow, would this "Junior" document still be useful without modification?
- YES → Good generic Junior document
- NO → Contains project leakage, needs cleanup or isn't a Junior document

**Enforcement:** Before modifying ANY file in `.cursor/rules/`, verify examples are generic, not project-specific.

## Summary

**Mode A (Junior only):** Triggers, decisions, real examples. No explanations of what I know.

**Mode B (Junior + User):** Decisions with enough context. Balance between triggering Junior and informing user.

**Mode C (User only):** Full explanations, examples, how-to. Assume user may not know patterns.

**Golden rule:** Match detail level to audience knowledge.

## CRITICAL: Junior Documents Are Always Mode A

**All files under `.cursor/` are Mode A (AI → AI) unless explicitly marked otherwise.**

### Pre-Write Checklist for Junior Documents

Before writing/updating any file in `.cursor/commands/` or `.cursor/rules/`:

- [ ] Is this explaining a concept I already know? → **DELETE**
- [ ] Is this implementation code (bash, python, etc.)? → **DELETE**
- [ ] Is this a verbose example when a trigger would work? → **SIMPLIFY**
- [ ] Would Wikipedia have this information? → **DELETE**
- [ ] Is this repeating something 3+ times in different words? → **DELETE repetition**
- [ ] Am I writing "how-to" instructions for myself? → **DELETE (I know how)**

### Mode A Template for Shared Modules

```markdown
# [Module Name] (AI Internal - Mode A)

## [Core Concept/Logic]
[Minimal description: WHAT to detect/do, not HOW - 3-5 lines]

## [Key Patterns/Rules]
[Bullet points of triggers/reminders - 5-10 lines]

## Templates (for consistency, if applicable)
[Message templates, question formats, response patterns]

## Usage
"Use [module] from _shared/[file].md"

[End - Target: 30-100 lines total depending on templates]
```

**Why templates are Mode A:**
- Templates ensure **consistency** in user-facing messages/questions
- They trigger **specific behavior patterns**
- They are **reference formats**, not teaching
- Example: Git status messages, clarification questions, progress displays

**Templates ≠ Teaching because:**
- Not explaining concepts
- Not showing implementation
- Not verbose tutorials
- Just standardized formats for consistency


### Red Flags (Mode C Creeping Into Mode A)

❌ **"Here's how to..."** → I know how, just tell me WHAT
❌ **Code blocks with bash/python/etc.** → I write code myself
❌ **40+ lines of examples** → Triggers work better than tutorials
❌ **"Step-by-step: 1. AI does X, 2. AI does Y..."** → Obvious, I know my flow
❌ **Multiple examples of same pattern** → One example is enough
❌ **Performance metrics** → Junior internal operations don't need metrics

### The Test

**Ask before writing:** *"If I (the AI) already know this, why is it here?"*

- **Answer: "To trigger/remind specific Junior behavior"** → KEEP (Mode A)
- **Answer: "To teach/explain a concept"** → DELETE (Mode C leaking in)
- **Answer: "To show how to implement"** → DELETE (I know implementation)

### Example: Mode A vs Mode C

❌ **Mode C (wrong for Junior docs):**
```markdown
## Stage Detection Process

Step 1: Check for component directories

```bash
ls .junior/features/comp-* 2>/dev/null
```

If command fails (no matches): **Stage 1**
If command succeeds: Continue to Step 2

Step 2: Check for features subdirectory within components

```bash
ls .junior/features/comp-*/features/ 2>/dev/null
```

[40 more lines of how-to...]
```

✅ **Mode A (correct for Junior docs):**
```markdown
## Detection Logic

**Stage 1:** No `comp-*/` under `.junior/features/`
**Stage 2:** `comp-*/` exists, NO `features/` subdirectory
**Stage 3:** `comp-*/` with `features/` subdirectory

**Returns:** "stage1" | "stage2" | "stage3"
```

**Why Mode A is better:** I know how to check for directories. Just tell me WHAT to check, not HOW to write the bash command.
