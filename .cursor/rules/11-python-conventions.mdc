---
alwaysApply: true
---

# Python Modern Conventions

## Type Hints (Python 3.10+)

**ALWAYS use modern type hint syntax:**

```python
# ✅ CORRECT - Modern Python 3.10+
from __future__ import annotations

def process(items: list[str]) -> dict[str, int]:
    result: dict[str, int] = {}
    optional_value: str | None = None
    return result

# ❌ WRONG - Old style (pre-3.10)
from typing import List, Dict, Optional

def process(items: List[str]) -> Dict[str, int]:
    result: Dict[str, int] = {}
    optional_value: Optional[str] = None
    return result
```

**Rules:**
- Use `list[X]` not `List[X]`
- Use `dict[K, V]` not `Dict[K, V]`
- Use `set[X]` not `Set[X]`
- Use `tuple[X, Y]` not `Tuple[X, Y]`
- Use `X | None` not `Optional[X]`
- Use `X | Y` not `Union[X, Y]`
- **Always add `from __future__ import annotations` at the top**

## Running Python Commands

**ALWAYS use `uv run` to run Python commands:**

```bash
# Run tests
uv run pytest
uv run pytest tests/test_advent_model.py -v

# Run Python scripts
uv run python -m app.main
uv run python scripts/migrate.py

# Run linting/formatting
uv run ruff check .
uv run ruff format .

# Run any Python tool
uv run mypy app/
uv run coverage run -m pytest
```

**Why `uv run`?**
- Automatically uses the correct virtual environment
- Ensures dependencies are installed and up-to-date
- No need to manually activate venv
- Consistent across all developers and CI/CD
- Works for ANY Python command, not just pytest

❌ **NEVER use:**
- `python script.py` (requires manual venv activation)
- `pytest` directly (may use wrong Python/environment)
- `.venv/bin/python` (verbose and error-prone)
- Manual venv activation (`source .venv/bin/activate`)

## Pytest Conventions

### Test Organization

**Use classes for grouping related tests:**

```python
class TestUserAuthentication:
    """Tests for user authentication flow."""

    @pytest.fixture
    def user(self):
        return User(username="test")

    def test_login_success(self, user):
        assert user.login("password")

    def test_login_failure(self, user):
        assert not user.login("wrong")
```

**Use functions for simple, independent tests:**

```python
def test_add_numbers():
    assert add(2, 3) == 5

def test_subtract_numbers():
    assert subtract(5, 3) == 2
```

**When to use classes:**
- Tests share fixtures
- Testing a specific class/component
- Logical grouping needed
- Multiple related test scenarios

**When to use functions:**
- Simple, independent tests
- No shared setup
- Testing pure functions

### Modern Pytest Features

```python
# ✅ Use parametrize for multiple test cases
@pytest.mark.parametrize("input,expected", [
    (2, 4),
    (3, 9),
    (4, 16),
])
def test_square(input, expected):
    assert square(input) == expected

# ✅ Use fixtures with type hints
@pytest.fixture
def database() -> Database:
    db = Database()
    yield db
    db.close()

# ✅ Use descriptive test names
def test_user_cannot_access_admin_page_without_permission():
    # Clear what is being tested
    pass
```

## Code Style

### Imports

```python
# Order: future, stdlib, third-party, local
from __future__ import annotations

import os
import sys

import pytest
from PySide6.QtCore import QObject

from app.models import User
```

### String Formatting

```python
# ✅ CORRECT - Use f-strings
name = "world"
message = f"Hello, {name}!"

# ❌ WRONG - Old style
message = "Hello, {}!".format(name)
message = "Hello, %s!" % name
```

### Dataclasses

```python
from dataclasses import dataclass

@dataclass
class Config:
    host: str
    port: int
    debug: bool = False
```

## Project-Specific: affera_translations

### No Build System

This is a **standalone application**, not a library:
- No `[build-system]` in pyproject.toml
- No wheel building
- Run directly with `uv run python -m app.main`

### Dependencies

**Production:**
- `pyside6` - Qt6 bindings
- `pyyaml` - YAML configuration

**Development:**
- `pytest` - Testing
- `pytest-qt` - Qt testing utilities

**NOT NEEDED:**
- ~~defusedxml~~ - We use QTranslator for .qm files, not XML parsing
- ~~tomli~~ - Python 3.11+ has built-in tomllib
- ~~hatchling~~ - No build system needed

## Ruff Configuration

Use ruff for linting and formatting:

```toml
[tool.ruff]
target-version = "py310"
line-length = 120

[tool.ruff.lint]
select = ["E", "F", "I", "UP"]  # UP = pyupgrade for modern Python
```

## Performance Testing

**ALWAYS use pytest-benchmark for performance testing.**

### Why pytest-benchmark?

✅ Statistical analysis (mean, median, stddev, outliers)
✅ Regression detection via `--benchmark-compare`
✅ Multiple iterations automatically
✅ Built-in warmup and calibration
❌ **NEVER use manual `time.perf_counter()` in tests**

### Basic Usage

```python
def test_function_performance(benchmark):
    """
    GIVEN a performance-critical function
    WHEN benchmarked
    THEN completes within target time
    """
    result = benchmark(my_function, arg1, arg2)

    # Verify correctness
    assert result == expected_value

    # Verify performance (benchmark.stats.mean is in seconds)
    mean_time_ms = benchmark.stats.mean * 1000
    assert mean_time_ms < 100, f"Too slow: {mean_time_ms:.2f}ms > 100ms"
```

### Running Benchmarks

```bash
# Run benchmarks
pytest tests/test_performance.py --benchmark-only

# Compare with baseline
pytest tests/ --benchmark-compare

# Save baseline
pytest tests/ --benchmark-save=baseline
```

### When to Write Performance Tests

✅ Performance-critical paths (parsing, algorithms, database queries)
✅ Features with explicit performance requirements
✅ Known bottlenecks
✅ APIs with latency SLAs

## Summary Checklist

- [ ] Use `from __future__ import annotations`
- [ ] Use modern type hints (`list`, `dict`, `X | None`)
- [ ] No `typing.List`, `typing.Optional`, etc.
- [ ] Classes for grouped tests, functions for simple tests
- [ ] f-strings for formatting
- [ ] No build system for standalone apps
- [ ] Type hint fixtures and functions
- [ ] Use pytest-benchmark for performance tests (not manual timing)

